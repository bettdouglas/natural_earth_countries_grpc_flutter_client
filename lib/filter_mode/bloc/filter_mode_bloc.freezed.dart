// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'filter_mode_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FilterModeStateTearOff {
  const _$FilterModeStateTearOff();

  _All all() {
    return const _All();
  }

  _Name name() {
    return const _Name();
  }

  _Boundary boundary() {
    return const _Boundary();
  }
}

/// @nodoc
const $FilterModeState = _$FilterModeStateTearOff();

/// @nodoc
mixin _$FilterModeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() all,
    required TResult Function() name,
    required TResult Function() boundary,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_All value) all,
    required TResult Function(_Name value) name,
    required TResult Function(_Boundary value) boundary,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilterModeStateCopyWith<$Res> {
  factory $FilterModeStateCopyWith(
          FilterModeState value, $Res Function(FilterModeState) then) =
      _$FilterModeStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$FilterModeStateCopyWithImpl<$Res>
    implements $FilterModeStateCopyWith<$Res> {
  _$FilterModeStateCopyWithImpl(this._value, this._then);

  final FilterModeState _value;
  // ignore: unused_field
  final $Res Function(FilterModeState) _then;
}

/// @nodoc
abstract class _$AllCopyWith<$Res> {
  factory _$AllCopyWith(_All value, $Res Function(_All) then) =
      __$AllCopyWithImpl<$Res>;
}

/// @nodoc
class __$AllCopyWithImpl<$Res> extends _$FilterModeStateCopyWithImpl<$Res>
    implements _$AllCopyWith<$Res> {
  __$AllCopyWithImpl(_All _value, $Res Function(_All) _then)
      : super(_value, (v) => _then(v as _All));

  @override
  _All get _value => super._value as _All;
}

/// @nodoc

class _$_All implements _All {
  const _$_All();

  @override
  String toString() {
    return 'FilterModeState.all()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _All);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() all,
    required TResult Function() name,
    required TResult Function() boundary,
  }) {
    return all();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
  }) {
    return all?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
    required TResult orElse(),
  }) {
    if (all != null) {
      return all();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_All value) all,
    required TResult Function(_Name value) name,
    required TResult Function(_Boundary value) boundary,
  }) {
    return all(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
  }) {
    return all?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
    required TResult orElse(),
  }) {
    if (all != null) {
      return all(this);
    }
    return orElse();
  }
}

abstract class _All implements FilterModeState {
  const factory _All() = _$_All;
}

/// @nodoc
abstract class _$NameCopyWith<$Res> {
  factory _$NameCopyWith(_Name value, $Res Function(_Name) then) =
      __$NameCopyWithImpl<$Res>;
}

/// @nodoc
class __$NameCopyWithImpl<$Res> extends _$FilterModeStateCopyWithImpl<$Res>
    implements _$NameCopyWith<$Res> {
  __$NameCopyWithImpl(_Name _value, $Res Function(_Name) _then)
      : super(_value, (v) => _then(v as _Name));

  @override
  _Name get _value => super._value as _Name;
}

/// @nodoc

class _$_Name implements _Name {
  const _$_Name();

  @override
  String toString() {
    return 'FilterModeState.name()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Name);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() all,
    required TResult Function() name,
    required TResult Function() boundary,
  }) {
    return name();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
  }) {
    return name?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_All value) all,
    required TResult Function(_Name value) name,
    required TResult Function(_Boundary value) boundary,
  }) {
    return name(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
  }) {
    return name?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name(this);
    }
    return orElse();
  }
}

abstract class _Name implements FilterModeState {
  const factory _Name() = _$_Name;
}

/// @nodoc
abstract class _$BoundaryCopyWith<$Res> {
  factory _$BoundaryCopyWith(_Boundary value, $Res Function(_Boundary) then) =
      __$BoundaryCopyWithImpl<$Res>;
}

/// @nodoc
class __$BoundaryCopyWithImpl<$Res> extends _$FilterModeStateCopyWithImpl<$Res>
    implements _$BoundaryCopyWith<$Res> {
  __$BoundaryCopyWithImpl(_Boundary _value, $Res Function(_Boundary) _then)
      : super(_value, (v) => _then(v as _Boundary));

  @override
  _Boundary get _value => super._value as _Boundary;
}

/// @nodoc

class _$_Boundary implements _Boundary {
  const _$_Boundary();

  @override
  String toString() {
    return 'FilterModeState.boundary()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Boundary);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() all,
    required TResult Function() name,
    required TResult Function() boundary,
  }) {
    return boundary();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
  }) {
    return boundary?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? all,
    TResult Function()? name,
    TResult Function()? boundary,
    required TResult orElse(),
  }) {
    if (boundary != null) {
      return boundary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_All value) all,
    required TResult Function(_Name value) name,
    required TResult Function(_Boundary value) boundary,
  }) {
    return boundary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
  }) {
    return boundary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_All value)? all,
    TResult Function(_Name value)? name,
    TResult Function(_Boundary value)? boundary,
    required TResult orElse(),
  }) {
    if (boundary != null) {
      return boundary(this);
    }
    return orElse();
  }
}

abstract class _Boundary implements FilterModeState {
  const factory _Boundary() = _$_Boundary;
}
